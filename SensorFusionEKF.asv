classdef SensorFusionEKF < handle
    properties
        x  % State [x, y, theta, v, omega]
        P  % Covariance matrix
        Q  % Process noise - Jacobian
        R  % Measurement noise - Jacobian
        measurementNoise % Measurement noise - Column Vector
        dt % Time step
        imuSub  % IMU subscriber
        odomSub % Odometry subscriber
        groundTruthSub
        node    % ROS2 Node
        odomLog           % Log for odometry pose [x, y, theta]
        groundTruthLog    % Log for ground truth pose [x, y, theta]
        stateLog  % Logging for trajectory
        logFile    % File handle for logging
        running % Boolean for starting and stopping sensor fusion
        timer

        T_world_odom  % Transform from odom to world frame
        isLogging = false
        x_offset
        y_offset
    end
    events
        PoseUpdated  % Event to trigger lidar callback
    end
    
    methods
        function obj = SensorFusionEKF(initialX, initialY, dt)
            % Constructor

            % Time step
            obj.dt = dt;

            % Store offsets
            obj.x_offset = initialX;
            obj.y_offset = initialY;

            % Store the transform from odom to world
            obj.T_world_odom = [1, 0, initialX;
                                0, 1, initialY;
                                0, 0, 1];

            % Create ros2 node for sensor fusion
            obj.node = ros2node('sensorFusionNode');

            % Initial state [x, y, theta, v, omega]
            obj.x = [0; 0; 0; 0; 0];

            % Debug print
            % disp('EKF Initial State:');
            % disp(obj.x);

            % Initial covariance matrix
            obj.P = eye(5);

            % Process noise covariance
            obj.Q = diag([0.1, 0.1, 0.05, 0.1, 0.05]);

            % Measurement noise (odom and IMU)
            obj.measurementNoise = [0.05; % x - odom
                                    0.05; % y - odom
                                    0.02; % theta - odom
                                    0.1; % v - IMU
                                    0.05]; % omega - IMU

            % Noise measurments converted to Jacobian
            obj.R = diag(obj.measurementNoise');

            % Initialize bool
            obj.running = false;
            
            % ROS2 Subscribers
            obj.imuSub = ros2subscriber(obj.node, '/chassis/imu', 'sensor_msgs/Imu');
            obj.odomSub = ros2subscriber(obj.node, '/chassis/odom', 'nav_msgs/Odometry');
            obj.groundTruthSub = ros2subscriber(obj.node, '/ground_truth_pose', 'tf2_msgs/TFMessage');

            %start(obj);
            % Create timer
            obj.timer = timer('ExecutionMode', 'fixedRate', ...
                            'Period', dt, ...
                            'TimerFcn', @(~,~)obj.run());
        end
        function startLogging(obj)
            % Open log file with error checking
            obj.logFile = fopen('trajectory_log.csv', 'w');
            
            % Write header
            fprintf(obj.logFile, 'odom_x,odom_y,odom_theta,truth_x,truth_y,truth_theta\n');
            obj.isLogging = true;
        end

        function stopLogging(obj)
            if ~obj.isLogging
                % Close log file
                fclose(obj.logFile);
                obj.isLogging = false;
            end
        end

        function trajectoryAnalysis(obj, plannedPath)
            % Stop logging before reading
            obj.stopLogging();
            
            % Read the data
            data = readmatrix('trajectory_log.csv');

            % Debug current state conversion
            current_local = [obj.x(1); obj.x(2); 1];
            current_world = obj.T_world_odom * current_local;
            disp('Current state conversion:');
            disp(['Local: [', num2str(obj.x(1)), ', ', num2str(obj.x(2)), ']']);
            disp(['World: [', num2str(current_world(1)), ', ', num2str(current_world(2)), ']']);
            
            % Debug first logged point conversion
            first_local = [data(1,1); data(1,2); 1];
            first_world = obj.T_world_odom * first_local;
            disp('First logged point conversion:');
            disp(['Local: [', num2str(data(1,1)), ', ', num2str(data(1,2)), ']']);
            disp(['World: [', num2str(first_world(1)), ', ', num2str(first_world(2)), ']']);
            
            % Debug transformation matrix
            disp('Transformation matrix:');
            disp([obj.T_world_odom]);
            
            % Transform odometry readings one by one for better debugging
            world_odom = zeros(size(data, 1), 2);
            world_ground = zeros(size(data, 1), 2);
            for i = 1:size(data, 1)
                % Get odometry position in local frame
                local_pos = [data(i, 1); data(i, 2); 1];
                % Transform to world frame
                world_pos = obj.T_world_odom * local_pos;
                world_odom(i, :) = world_pos(1:2)';
                world_ground(i, :) = [data(i, 4)+11.975, data(i, 5)+17.975];
            end

            if nargin > 1 && ~isempty(plannedPath)
        % Analyze path deviation
        % For each point in the ground truth, find closest point on planned path
        path_errors = zeros(size(world_ground, 1), 1);
        for i = 1:size(world_ground, 1)
            % Calculate distances to all points on planned path
            distances = sqrt(sum((plannedPath - world_ground(i,:)).^2, 2));
            % Find minimum distance (closest point)
            path_errors(i) = min(distances);
        end
        
        % Calculate path error statistics
        mean_path_error = mean(path_errors);
        median_path_error = median(path_errors);
        max_path_error = max(path_errors);
        std_path_error = std(path_errors);
        rms_path_error = rms(path_errors);
        
        % Create error distribution subplot
        figure('Name', 'Path Error Analysis');
        subplot(2,1,1);
        histogram(path_errors, 30, 'Normalization', 'probability');
        title('Path Error Distribution');
        xlabel('Error Distance (m)');
        ylabel('Probability');
        grid on;
        
        % Plot error over time
        subplot(2,1,2);
        plot(1:length(path_errors), path_errors, 'b-');
        title('Path Error Over Time');
        xlabel('Sample Number');
        ylabel('Error Distance (m)');
        grid on;
        
        % Print statistics
        disp('Path Error Statistics:');
        disp(['Mean Error: ', num2str(mean_path_error), ' m']);
        disp(['Median Error: ', num2str(median_path_error), ' m']);
        disp(['Max Error: ', num2str(max_path_error), ' m']);
        disp(['Standard Deviation: ', num2str(std_path_error), ' m']);
        disp(['RMS Error: ', num2str(rms_path_error), ' m']);
        
        % Calculate what percentage of time robot was within different error thresholds
        error_thresholds = [0.1, 0.2, 0.5, 1.0]; % meters
        for threshold = error_thresholds
            within_threshold = sum(path_errors < threshold) / length(path_errors) * 100;
            disp(['Time within ', num2str(threshold), 'm: ', num2str(within_threshold), '%']);
        end
    end
            
            % Create plot
            figure('Name', 'Robot Trajectory Analysis');
            hold on;
            grid on;
            
            % Plot trajectories
            plot(world_odom(:,1), world_odom(:,2), 'b-', 'DisplayName', 'Odometry');
            plot(world_ground(:,1), world_ground(:,2), 'r-', 'DisplayName', 'Ground Truth');
            
            % Plot planned path if provided
            if nargin > 1 && ~isempty(plannedPath)
                plot(plannedPath(:,1), plannedPath(:,2), 'g--', 'LineWidth', 2, 'DisplayName', 'Planned Path');
                % Plot start and goal of planned path
                plot(plannedPath(1,1), plannedPath(1,2), 'go', 'MarkerSize', 10, 'DisplayName', 'Path Start');
                plot(plannedPath(end,1), plannedPath(end,2), 'g*', 'MarkerSize', 10, 'DisplayName', 'Path Goal');
            end
            
            % Plot start points
            plot(world_odom(1,1), world_odom(1,2), 'bo', 'DisplayName', 'Odom Start', 'MarkerSize', 10);
            plot(world_ground(1,1), world_ground(1,2), 'ro', 'DisplayName', 'Truth Start', 'MarkerSize', 10);
            
            % Add labels and legend
            title(sprintf('Robot Trajectory Comparison\nTransform: [%0.2f, %0.2f]', obj.x_offset, obj.y_offset));
            xlabel('X Position (m)');
            ylabel('Y Position (m)');
            legend('Location', 'best');
            axis equal;
            
            % Print statistics
            disp('Trajectory Statistics:');
            total_distance_odom = sum(sqrt(sum(diff(world_odom).^2, 2)));
            total_distance_truth = sum(sqrt(sum(diff(world_ground).^2, 2)));
            disp(['Total Distance (Odometry): ', num2str(total_distance_odom), ' m']);
            disp(['Total Distance (Ground Truth): ', num2str(total_distance_truth), ' m']);
            if nargin > 1 && ~isempty(plannedPath)
                planned_distance = sum(sqrt(sum(diff(plannedPath).^2, 2)));
                disp(['Planned Path Length: ', num2str(planned_distance), ' m']);
            end
            
            % Calculate errors
            x_errors = world_odom(:,1) - world_ground(:,1);
            y_errors = world_odom(:,2) - world_ground(:,2);
            theta_errors = data(:,3) - data(:,6);  % angular errors
            
            % Create figure with subplots
            figure('Name', 'Trajectory Error Analysis');
            
            % X-error distribution
            subplot(3,2,1);
            histogram(x_errors, 30, 'Normalization', 'probability');
            title('X Position Error Distribution');
            xlabel('Error (m)');
            ylabel('Probability');
            
            % Y-error distribution
            subplot(3,2,2);
            histogram(y_errors, 30, 'Normalization', 'probability');
            title('Y Position Error Distribution');
            xlabel('Error (m)');
            ylabel('Probability');
            
            % Theta error distribution
            subplot(3,2,3);
            histogram(theta_errors, 30, 'Normalization', 'probability');
            title('Theta Error Distribution');
            xlabel('Error (rad)');
            ylabel('Probability');
            
            % 2D error scatter
            subplot(3,2,4);
            scatter(x_errors, y_errors, 10, 'filled');
            title('Position Error Distribution');
            xlabel('X Error (m)');
            ylabel('Y Error (m)');
            axis equal;
            grid on;
            
            % Error over time
            subplot(3,2,[5,6]);
            plot(1:length(x_errors), sqrt(x_errors.^2 + y_errors.^2));
            title('Total Position Error Over Time');
            xlabel('Sample Number');
            ylabel('Error Magnitude (m)');
            grid on;
            
            % Print statistics
            disp('Error Statistics:');
            disp('X Position Error:');
            disp(['  Mean: ', num2str(mean(x_errors))]);
            disp(['  Median: ', num2str(median(x_errors))]);
            disp(['  Std Dev: ', num2str(std(x_errors))]);
            disp(['  RMS: ', num2str(rms(x_errors))]);
            
            disp('Y Position Error:');
            disp(['  Mean: ', num2str(mean(y_errors))]);
            disp(['  Median: ', num2str(median(y_errors))]);
            disp(['  Std Dev: ', num2str(std(y_errors))]);
            disp(['  RMS: ', num2str(rms(y_errors))]);
            
            disp('Theta Error (rad):');
            disp(['  Mean: ', num2str(mean(theta_errors))]);
            disp(['  Median: ', num2str(median(theta_errors))]);
            disp(['  Std Dev: ', num2str(std(theta_errors))]);
            disp(['  RMS: ', num2str(rms(theta_errors))]);
            
            % Calculate total position error statistics
            total_pos_error = sqrt(x_errors.^2 + y_errors.^2);
            disp('Total Position Error:');
            disp(['  Mean: ', num2str(mean(total_pos_error))]);
            disp(['  Median: ', num2str(median(total_pos_error))]);
            disp(['  Std Dev: ', num2str(std(total_pos_error))]);
            disp(['  RMS: ', num2str(rms(total_pos_error))]);
        end
        function obj = start(obj)
            obj.running = true;
            start(obj.timer);
        end

        function obj = stop(obj)
            obj.running = false;
            stop(obj.timer);
            delete(obj.timer);
        end
        
        function x_next = state_transition(obj)
            % State transition function
            theta = obj.x(3);
            % v and omega remain the same
            v = obj.x(4);
            omega = obj.x(5);
            
            % Update state
            x_next = obj.x;
            x_next(1) = obj.x(1) + v * obj.dt * cos(theta);
            x_next(2) = obj.x(2) + v * obj.dt * sin(theta);
            x_next(3) = obj.x(3) + omega * obj.dt;
        end

        % Replace getWorldState() with this:
        function world_state = getState(obj)
            if isempty(obj.x)
                world_state = [];
            else
                % Transform local state to world coordinates when needed
                local_pos = [obj.x(1); obj.x(2); 1];
                world_pos = obj.T_world_odom * local_pos;
                
                world_state = obj.x;
                world_state(1) = world_pos(1);
                world_state(2) = world_pos(2);
            end
        end
        
        function F = compute_state_to_jacobian(obj)
            % Compute Jacobian of the state transition model
            theta = obj.x(3);
            v = obj.x(4);
            
            F = [1, 0, -v * obj.dt * sin(theta), obj.dt * cos(theta), 0;
                 0, 1,  v * obj.dt * cos(theta), obj.dt * sin(theta), 0;
                 0, 0, 1,                         0,                  obj.dt;
                 0, 0, 0,                         1,                  0;
                 0, 0, 0,                         0,                  1];
        end
        
        % Method to perform sensor fusion
        function obj = run(obj)
            try
                odomMsg = receive(obj.odomSub, 1);
                imuMsg = receive(obj.imuSub, 1);
                
                if ~isempty(odomMsg) && ~isempty(imuMsg)
                    % Extract odometry and IMU data
                    odom_x = odomMsg.pose.pose.position.x;
                    odom_y = odomMsg.pose.pose.position.y;
                    odom_theta = quat2eul([odomMsg.pose.pose.orientation.w, ...
                                  odomMsg.pose.pose.orientation.x, ...
                                  odomMsg.pose.pose.orientation.y, ...
                                  odomMsg.pose.pose.orientation.z], 'ZYX');
                    odom_theta = odom_theta(1);
                    
                    imu_lin_acc = imuMsg.linear_acceleration.x;
                    imu_ang_vel = imuMsg.angular_velocity.z;

                    if obj.isLogging
                        groundTruthMsg = receive(obj.groundTruthSub, 1);

                        groundTruthX = groundTruthMsg.transforms.transform.translation.x;
                        groundTruthY = groundTruthMsg.transforms.transform.translation.y;
                        groundTruthTheta = quat2eul([groundTruthMsg.transforms.transform.rotation.w, ...
                                                     groundTruthMsg.transforms.transform.rotation.x, ...
                                                     groundTruthMsg.transforms.transform.rotation.y, ...
                                                     groundTruthMsg.transforms.transform.rotation.z], 'ZYX');
                        groundTruthTheta = groundTruthTheta(1);

                        % Log raw odometry values
                        fprintf(obj.logFile, '%f,%f,%f,%f,%f,%f\n', ...
                        odom_x, odom_y, odom_theta, ...
                        groundTruthX, groundTruthY, groundTruthTheta);
                    end
                    
                    % Prediction step
                    F = obj.compute_state_to_jacobian();
                    obj.x = obj.state_transition();
                    obj.P = F * obj.P * F' + obj.Q;
                    
                    % Measurement and update
                    v_est = obj.x(4) + imu_lin_acc * obj.dt;
                    z = [odom_x; odom_y; odom_theta; v_est; imu_ang_vel] + diag(obj.R) .* randn(5, 1);
                    
                    % Kalman Gain
                    H = eye(5);
                    K = obj.P * H' / (H * obj.P * H' + obj.R);
                    obj.x = obj.x + K * (z - H * obj.x);
                    obj.P = (eye(5) - K * H) * obj.P;
        
                    % Debug prints
                    %disp('EKF Current pose:');
                    %disp(obj.getState);
        
                    % Trigger PoseUpdated event
                    notify(obj, 'PoseUpdated');
                end
                
            catch e
                disp('Error in EKF run:');
                disp(e.message);
            end
        end
        function delete(obj)
            disp('Cleaning up Sensor Fusion object...');
            
            % Stop logging before reading
            obj.stopLogging();

            % Clean up timer
            try
                if ~isempty(obj.timer) && isvalid(obj.timer)
                    stop(obj.timer);
                    delete(obj.timer);
                end
            catch e
                disp(e.message);
            end
            
            % Clean up subscribers
            if ~isempty(obj.imuSub)
                clear obj.imuSub;
            end
            if ~isempty(obj.odomSub)
                clear obj.odomSub;
            end
  
            
            % Clean up node last
            if ~isempty(obj.node)
                delete(obj.node);
            end
            
            disp('Sensor Fusion cleanup complete.');
        end
    end
end
        % % Method to perform sensor fusion
        % function obj = run(obj)
        %     odomMsg = receive(obj.odomSub, 10);
        %     imuMsg = receive(obj.imuSub, 10);
        %     %groundTruthMsg = receive(obj.groundTruthSub, 10);
        % 
        %     % Extract odometry and ground truth data
        %     odom_x = odomMsg.pose.pose.position.x;
        %     odom_y = odomMsg.pose.pose.position.y;
        %     odom_theta = quat2eul([odomMsg.pose.pose.orientation.w, ...
        %                            odomMsg.pose.pose.orientation.x, ...
        %                            odomMsg.pose.pose.orientation.y, ...
        %                            odomMsg.pose.pose.orientation.z], 'ZYX');
        %     odom_theta = odom_theta(1);
        % 
        %     % groundTruthX = groundTruthMsg.transforms.transform.translation.x;
        %     % groundTruthY = groundTruthMsg.transforms.transform.translation.y;
        %     % groundTruthTheta = quat2eul([groundTruthMsg.transforms.transform.rotation.w, ...
        %     %                              groundTruthMsg.transforms.transform.rotation.x, ...
        %     %                              groundTruthMsg.transforms.transform.rotation.y, ...
        %     %                              groundTruthMsg.transforms.transform.rotation.z], 'ZYX');
        %     % groundTruthTheta = groundTruthTheta(1);
        % 
        %     % Log the data
        %     %obj.odomLog = [obj.odomLog; odom_x, odom_y, odom_theta];
        %     %obj.groundTruthLog = [obj.groundTruthLog; groundTruthX, groundTruthY, groundTruthTheta];
        % 
        %     imu_lin_acc = imuMsg.linear_acceleration.x;
        %     imu_ang_vel = imuMsg.angular_velocity.z;
        % 
        % 
        %     % Prediction step
        %     F = obj.compute_state_to_jacobian();
        %     obj.x = obj.state_transition();
        %     obj.P = F * obj.P * F' + obj.Q;
        % 
        %     % Measurement and update
        %     v_est = obj.x(4) + imu_lin_acc * obj.dt;
        %     z = [odom_x; odom_y; odom_theta; v_est; imu_ang_vel] + diag(obj.R) .* randn(5, 1);
        % 
        %     % Kalman Gain
        %     H = eye(5);
        %     K = obj.P * H' / (H * obj.P * H' + obj.R);
        %     obj.x = obj.x + K * (z - H * obj.x);
        %     obj.P = (eye(5) - K * H) * obj.P;
        % 
        %     % Debug prints
        %     %disp('EKF Current pose:');
        %     %disp(obj.getState);
        % 
        %     % Trigger PoseUpdated event
        %     notify(obj, 'PoseUpdated');
        % end
